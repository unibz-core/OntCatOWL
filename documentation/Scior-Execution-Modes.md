# Scior: Execution Modes

This document presents all Scior arguments and their usage.

## Contents

- [Arguments](#arguments)
- [Input Ontology File](#input-ontology-file)
- [Default Arguments’ Values](#default-arguments-values)
- [Automation Level Modes](#automation-level-modes)
    - [Automation Level Example](#automation-level-example)
- [Models’ Completeness Modes](#models-completeness-modes)
    - [Models’ Completeness Modes Example](#models-completeness-modes-example)
- [Complementary Arguments](#complementary-arguments)
- [Help and Version](#help-and-version)

## Arguments

For executing Scior, the user should provide arguments related to the software’s automation level and to the input
model’s completeness. The Scior’s usage generated by the [Python *
argparse* library](https://docs.python.org/3/library/argparse.html) is:

```txt
scior [-h] [-i | -a] [-owa | -cwa] [-t] [-g1] [-g2] [-v] ontology_file
```

We are going to present each one of the arguments in the next sections.

## Input Ontology File

The only mandatory argument is `ontology_file`, which is the path to the input ontology file. This file can be stored
locally (i.e., offline in the user’s file system) or remotely (i.e., online, web stored)* and is the ontology that is
going to have its semantics improved by Scior.

We implemented Scior using the [RDFLib Python library](https://rdflib.readthedocs.io/en/stable/), hence the software
accepts rdf-based ontology files written in all its supported syntaxes. Once the syntax is valid, Scior automatically
identifies and processes it. For consulting a table with all supported syntaxes, please refer to
the [RDFLib parsing documentation page](https://rdflib.readthedocs.io/en/stable/intro_to_parsing.html).

- Check [open issue #15](https://github.com/unibz-core/Scior/issues/15) status for validating this information.

## Default Arguments’ Values

The default values for each one of the user’s arguments are:

- **True** for: n (incomplete) and i (interactive)
- **False** for: c (complete), a (automatic), r, t, g1, and g2

The default value of an argument is assumed if the user does not provide specifications about it.

## Automation Level Modes

The Scior provides two possible execution ways regarding user’s interactivity: totally automatic (i.e., no interaction
is required at any moment) or interactive execution (when the user can provide information whenever necessary). The
arguments for setting these execution modes are:

```txt
-i, --interactive Execute automatic rules whenever possible. Execute interactive rules only if necessary (default).
-a, --automatic Execute only automatic rules. Interactive rules are not performed.
```

As a premise, Scior always considers the number of possibilities to (positively or negatively) attribute a
classification to a class: if the number of possibilities is one, no interaction is needed and hence it automatically
attributes the classification to the class. If the number of possibilities is higher than one, Scior will require the
user's interaction or report the situation to the user, when in the interactive and automatic modes, respecivelly.

While some rules are performed the same way in both modes, others have different behaviors when the user sets different
configurations. We present the different behavior of all rules regarding the automation level and regarding models’
completeness modes in
the [implemented rules documentation](https://github.com/unibz-core/Scior/blob/main/documentation/Scior-ImplementedRules.md)
.

### Automation Level Example

As an example, please consider an ontology with an isolated class (i.e., with no defined superclasses or subclasses)
named Employee and that no information is asserted about this class’s ontological classification.

As UFO states that every type must supply or carry a single identity principle or aggregate multiple identity
principles, we can logically make conclusions about the class Employee. If the user states that the ontology containing
this class is complete ([see next section](#models-completeness-modes)), the only option available to Employee is to be
set as a `gufo:Kind`, as it needs to provide its own identity principle. This happens because no other class can do
that (as it has no superclasses) and because it cannot aggregate different identity principles from other classes (as it
has no subclasses). The [**rule
n_r_t**](https://github.com/unibz-core/Scior/blob/main/documentation/Scior-ImplementedRules.md#rule-n_r_t) formalizes
this necessity, stating that “*in complete models, every type without supertypes and without subtypes must be
a `gufo:Kind`*”.

Considering that the user has informed that the input model is **complete**, the actions produced by this rule do not
vary according to the defined level of automation set. This happens because there is only one gUFO classification
available for the Employee class, which is `gufo:Kind`. Consequently, this classification is asserted to the class.

On the other hand, if the user sets the model as **incomplete**, the actions produced by this rule will vary according
to the informed automation level. If **interactive**, Scior will ask the user if he wants to set the class as
a `gufo:Kind`, but if the level is set as **automatic**, then the software will report an incompleteness problem (as
there is no information regarding the class’s identity principle)–this action is taken because there are more than one
classification that could be associated to the class and, hence, in the automatic level Scior cannot determine the
class’s classification.

## Models’ Completeness Modes

Another fundamental piece of information that the user must provide to Scior is the completeness of the model to be
evaluated. Scior considers this information for performing different actions according to the input model’s
completeness. The two available options are:

```txt
-n, --incomplete The loaded ontology is an incomplete model (default).
-c, --complete The loaded ontology is a complete model.
```

RDF-based knowledge graphs are implemented over
the [open-world assumption](https://en.wikipedia.org/wiki/Open-world_assumption) paradigm, where unknown information may
be true or false—i.e., in this paradigm, it is supposed that the model may be **incomplete**. Pieces of information may
be (intentionally or not) missing from the input file and the Scior engine must know that to correctly infer the
ontological categories of each entity. On one hand, considering a model incomplete may cause Scior to identify more
possibilities to be displayed to the user’s choice when using the interactive mode, but it may also lead to fewer
inferences when in the automatic mode.

When informing that the input model is complete, Scior performs in
a [closed-world](https://en.wikipedia.org/wiki/Closed-world_assumption) situation, where all unknown information is
assumed to be false. The consequence of setting a model as complete is that Scior can perform more inferences,
especially when in the automatic mode, as it can assume some information to be true, generating fewer possibilities. In
contrast, the user must know that setting an incomplete model as complete will lead Scior to generate inconsistencies (
which cause the software to interrupt its execution) instead of incompleteness (which is only reported as a warning).

While some rules are performed the same way in both modes, others have different behaviors when the user sets different
configurations. We present the different behavior of all rules regarding the automation level and regarding models’
completeness modes in
the [implemented rules documentation](https://github.com/unibz-core/Scior/blob/main/documentation/Scior-ImplementedRules.md)
.

### Models’ Completeness Modes Example

In this example, please consider the taxonomy of an ontology *in* presented in the image below. As can be seen, the
ontology *in* is composed of only three classes: Furniture, Table, and Chair, with the last two classes being classified
as `gufo:Kinds`. In the image, black arrows represent `rdfs:subClassOf` properties and orange arrows
represent `rdf:type` properties.

<img src="https://user-images.githubusercontent.com/8641647/209947857-c2d29bd2-b9b7-46d4-8db1-102e1795aaaf.jpg" width="400">

As previously said in the [last example](#automation-level-example), UFO–and consequently gUFO–states that every type
must supply or carry a single identity principle or aggregate multiple identity principles. Table and Chair already
supply their own identity principle, as they are `gufo:Kinds`, hence the only option for Furniture would be to be an
entity type that aggregates multiple identity principles–these types are the `gufo:NonSortals`, which can be of four
types: `gufo:Category`, `gufo:Mixin`, `gufo:PhaseMixin`, and `gufo:RoleMixin`.

The second UFO rule we must consider in this example is that rigid types (like `gufo:Kinds`) cannot specialize
Anti-Rigid types (like `gufo:RoleMixins` or `gufo:PhaseMixins`). Now, let us analyze the consequences of both rules for
the example provided in the image above in two different scenarios: considering the input model as incomplete and as
complete.

In the first case, when the model is said to be incomplete, it is not possible to infer a definitive (i.e., a more
specific) ontological category to the Furniture class. The only certain information is, according to the two UFO rules
presented here, that Furniture must be classified as `gufo:NonSortal` and as **not** a `gufo:AntiRigidType`–thus
Furniture may be a `gufo:Mixin` or a `gufo:Category`, as both are Non-Sortals and not Anti-Rigid. This happens because,
although it has two subclasses that are Sortals and Rigid (two `gufo:Kinds`), it may have other unknown subclasses of
different types. As an example, please refer to the left box in the image below.

<img src="https://user-images.githubusercontent.com/8641647/209947869-0dde097e-de4c-4f66-8f6a-c1ad3eca68ec.jpg" width="1000">

We represent, in this example, a scenario where the class Furniture has another subclass called Borrowed Furniture,
which is classified as a `gufo:RoleMixin`, that is a `gufo:NonSortal` and `gufo:AntiRigidType` type. Here the class
Furniture would aggregate different identity principles from Rigid and Anti-Rigid types and, hence, would be classified
as a `gufo:Mixin`. Please note that this is just one possible scenario among many other ones, as nothing more can be
asserted than the information presented in the first image of this example.

By considering the model as complete, we are certain that the Furniture class has no other subclass and that, hence,
that it is a `gufo:NonSortal` that aggregates only `gufo:RigidTypes`, being a `gufo:Category`, which is the only viable
gUFO categorization available to it. We illustrated this scenario in the right box in the image above.

In Scior, we implemented [**rule
ns_sub_r**](https://github.com/unibz-core/Scior/blob/main/documentation/Scior-ImplementedRules.md#rule-ns_sub_r), which
the union of the two UFO statements presented in this example and used here. This rule states that “*in complete
models, `gufo:NonSortals` with only `gufo:RigidTypes` direct subtypes are always `gufo:Categories`*”. Scior does not
even execute this rule for models set as incomplete, as its other features already identify the higher-level classes’
categories.

## Complementary Arguments

Scior provides other useful complementary arguments:

```txt
-t, --times Print on the screen the execution times of all functions.
-g1, --gufo1 Import gUFO ontology in the output ontology file.
-g2, --gufo2 Save all gUFO statements in the output ontology file.
```

The first argument, **times**, prints on the screen the execution times for all executions of every implemented rule. 
Also, at the conclusion of the software, it prints a table aggregating all recorded times.

The last two arguments of this group regard the output file generated after the Scior execution. At the end of the
software execution, Scior saves an output file containing all the discovered gUFO information (more
information [here](https://github.com/unibz-core/Scior/blob/main/documentation/Scior-Functioning.md#output-ontology)).
This file only references the gUFO concepts in its assertions (so the only known gUFO information is the one that is
contained in the file).

If the user wants to store or manipulate **gUFO** information in the output file, this can be done through the
options `g1` and `g2`. The former uses the [`owl:imports` property](https://www.w3.org/TR/owl-ref/#imports-def) to
reference and exhibit all gUFO in the output file. The latter argument merges the output file with gUFO, creating a
unique ontology with all statements.

## Help and Version

The two final arguments are the ones the print the help message and to print the software version, as follows:

```txt
-h, --help show this help message and exit
-v, --version Print the software version and exit.
```

The **help** argument is a default functionality provided by the [Python *
argparse* library](https://docs.python.org/3/library/argparse.html). When a user requests help, the software returns a
string containing a help message, including the program usage and information about its available arguments. Finally,
the **version** argument simply prints the version of Scior being executed.
